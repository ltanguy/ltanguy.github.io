{"categories":[],"posts":[{"content":"TLS Mutual Authentication (TLS MA or more commonly nowadays mTLS) is increasingly being leveraged for securing links between applications (see the section of Istio\u0026rsquo;s documentation on security as an example).\nIt provides a much more robust and secure solution than static shared credentials:\n Shared credentials are susceptible to brute-force attacks. mTLS is not. Shared credentials should be periodically rotated. In practice, this is almost never the case as the process is particularly painful and implies the rotation of the credentials at the server and client level simultaneously. In constrast, mTLS allows the client or the server to rotate their public/private key pair independently. When done correctly, accessing the client private key implies a shell access to the client servers and are harder to steal.  That said, mTLS is admittedly harder to setup and has some pre-requisites: having deployed a Certificate Authority (CA), having a good operation tooling for the deployment and maintenance of those secrets and more importantly having devs and ops understand how the pieces fits together.\nI was involved recently in a design discussion on how to secure an edge gateway facing multiple third-parties, relying on mTLS to authenticate connections from remote services. I was painfully reminded how hard it is, even for seasoned technical or security specialists, to reason about mTLS and what it means in terms of authorization for applications. For most people, mTLS is a very different beast than all other authentication methods. Spoiler: it\u0026rsquo;s not (that much).\nSome important properties of certificates in a Public Key Infrastructure X.509 Certificates are basically a bunch of metadatas, notably:\n The public RSA/DSA/EC public key associated with the private key the service holds A period of validity (NotBefore and NotAfter) The identity and a signature of the CA that issued the certificate Informations on how to use this certificate (Constraints) A Subject attribute  This Subject attribute has the form of a X.500 Distinguished Name (for example: CN=HR System,OU=HR,O=ACME). The only guarantee CA provides is that all certificates with a given Subject attribute are emitted to the same person or application.\nQuoting RFC 5280 on X.509 certificates:\n Where it is non-empty, the subject field MUST contain an X.500 distinguished name (DN). The DN MUST be unique for each subject entity certified by the one CA as defined by the issuer field. A CA MAY issue more than one certificate with the same DN to the same subject entity.\n This happens usually when:\n A renewal of the certificate happened. Usually the previous certificate is expired or revoked. The application that represents this Subject is deployed in HA. Each service has its own private key and certificate.  All other attributes in the certificate (notably subjectAltName) have usually no unicity guarantees.\nAlso, the DN of the certificate is arbitrary. It can be as simple as CN=HR System or as complex as CN=HR System,OU=Global HR,O=ACME,C=FR. All certificate authorities have different policies for naming.\nIt\u0026rsquo;s important to be aware that in no way the CA guarantees that the CN attribute in the DN is unique. Two certificates emitted by the CA to two different parties can share the same CN, for example CN=HR System,OU=Global HR,O=ACME,C=FR and CN=HR System,OU=Other HR Service,O=ACME,C=FR.\nmTLS Basics I won\u0026rsquo;t dive into the details of mTLS, just outline some important properties of certificates in the context of authentication and authorization with mTLS. For a refresh on mTLS, see this article for example.\nmTLS implies two things:\n the server exposes a non-expired server certificate, signed by a CA that the client trusts, that references the FQDN of the server in the subjectAltName attribute (not the CN of the certificate) the client has a non-expired client certificate, signed by a CA the server trusts for authentication.  mTLS with a single trusted CA Let\u0026rsquo;s imagine a scenario where a service exposes two sets of API A and B. API A can be accessed by client 1 and API B can only be accessed by client 2. You absolutely do not want client 1 to access API B and inversely. Both clients use certificates emitted by the same Certificate Authority.\n This is the easy road. In this scenario, the Subject DN of the client certificate is the identity the service can rely on for authorization on its API.\nIt\u0026rsquo;s important though to rely on the whole DN and not only the CN as it may not be unique, as seen previously. It particularly holds true if the client uses a certificate emitted by a public CA.\nmTLS with multiple trusted CA This is there where things usually go wrong.\nLet\u0026rsquo;s take the previous scenario, but now each client uses a client certificate emitted by two different certificate authorities. This is a frequent setup if you expose your services to partners through an edge gateway.\n Depending on the technology used for implementing the service, you either:\n trust globally all the CAs on all your services. This is the case for Java, where the trust is global at the JVM level. create something similar to Virtual Hosts in Apache or Nginx, where you trust only one CA and do authorization in this compartment.  Global trust In the first case, if you rely solely on the DN of the Subject to authenticate the clients, it is possible for an attacker to generate a certificate on the second CA with the same DN and access your service. This is bad.\nThis is not uncommon. Let\u0026rsquo;s look at the documentation of authorizations in Apache Kafka:\n By default, the name of the principal identified by a TLS/SSL certificate is the DN (X.500 Distinguished Name) of that certificate (also known as the Subject), which uses the form CN=writeuser,OU=Unknown,O=Unknown,L=Unknown,ST=Unknown,C=Unknown. You can use ssl.principal.mapping.rules to translate the DN to a more manageable principal name.\n If your Kafka cluster is trusting more than one CA, you\u0026rsquo;re potentially vulnerable. In this context, the usage of mapping rules to extract an identifier from the DN adds another layer of danger.\nIn general, you can be tempted to check the format of the DN or trusting too much the issuance process of the CA. For example: thinking that the issuance process of the CA ensures that you\u0026rsquo;re necessarily authorized by ACME corporation to request certificates with a subject containing O=ACME.\nChances are that it is not the case.\nVirtual Hosts In the second case, you\u0026rsquo;re at first sight back to the single CA scenario, but this strategy will be probably hard to maintain as you add other CAs.\nThis strategy will also have impacts on how you expose your services to partners, as the server needs to determine on which Virtual Host in needs to route the incoming request:\n Use a different FQDN for each Virtual Host (if all your clients supports Server Name Indication / SNI). Use a different port for each Virtual Host Use a different IP for each Virtual Host (and as a consequence a different FQDN)  This also couples a lot of your applicative security to the infrastructure configuration, which is never a good idea.\nA simple universal solution People familiar with Radius or Kerberos will probably remember fondly the notion of realms.\nmTLS can (and must) be considered similarly:\n Trusting a CA on your service basically means trusting the realm that is managed by this CA. This realm is defined by the Subject DN of this CA, which will appear in each certificate emitted by it. It may still be a good idea to ensure that you\u0026rsquo;re not trusting two CAs with the same Subject (though it\u0026rsquo;s unlikely). The client identity is determined by the combination of the Subject DN and the Issuer DN of its certificate, for example CN=HR System,OU=HR,O=ACME,C=FR@O=ACME,C=FR. This identifier is guaranteed to be unique across all certificates emitted by the CAs you trust.  This approach is simple, works independently of the number of CAs you trust in your application and makes no hypothesis on the format of Subject DN or Issuer DN.\nIf the application in the examples is an edge gateway and fine-grained authorization is done in backend-services, it must propagates those two attributes.\nThe inherent complexity of mTLS makes us easily forget the basic properties of authentication and authorizations: the user must prove its identity, its identifier must be unique in the system and authorization must be based on this unique identifier.\n","id":0,"section":"posts","summary":"TLS Mutual Authentication (TLS MA or more commonly nowadays mTLS) is increasingly being leveraged for securing links between applications (see the section of Istio\u0026rsquo;s documentation on security as an example).\nIt provides a much more robust and secure solution than static shared credentials:\n Shared credentials are susceptible to brute-force attacks. mTLS is not. Shared credentials should be periodically rotated. In practice, this is almost never the case as the process is particularly painful and implies the rotation of the credentials at the server and client level simultaneously.","tags":["mTLS","security","authorization","authentication"],"title":"Authorization with TLS Mutual Authentication","uri":"https://ltanguy.github.io/2020/05/tls-ma-authorization/","year":"2020"}],"tags":[{"title":"authentication","uri":"https://ltanguy.github.io/tags/authentication/"},{"title":"authorization","uri":"https://ltanguy.github.io/tags/authorization/"},{"title":"mTLS","uri":"https://ltanguy.github.io/tags/mtls/"},{"title":"security","uri":"https://ltanguy.github.io/tags/security/"}]}